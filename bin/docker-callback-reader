#!/bin/bash
#
# This script is run as a cron job within an account in the docker group.  It
# is used to accept requests from a housekeeping container within an application
# and to pass these to over containers within the same application.
#
# It creates and listens to a pipe ${CALL_BACK_DIR}/call-back.pipe, and receives
# commands of the form <app> <service> <args> where <app>_<service>
# is a valid docker container.  This script detaches:
#
#     docker exec <app>_<service> docker-service-callback.sh <args>
#
# hence the receiving container must include a valid callback_request script
# on its path, and which is able to process and dispatch such a request.
#
# This callback service muct be enabled within a container by volume mapping
# this pipe into the requesting container, e.g.
#
#     volumes:
#       - ${CALL_BACK_DIR}:/run/host-callback
#
# Exit if this script is already running. pgrep is used to do this but note that 
# the cron deamon wraps the crontab line in a process that embeds $0 hence the 
# check for the bare $0+EOL
#
echo "Restarting at $(date)"

[[ $(pgrep -c -u $USER -f "$0\$") -gt 1 ]]  && exit

echo "Entering Poll on Application Pipe"

cd $(dirname $(dirname $(realpath $0)))
. .env

PIPE=${CALL_BACK_DIR}/call-back.pipe
trap "sudo rm -f $PIPE" EXIT

[[ -p $PIPE ]] || ( sudo mkfifo -m 660 $PIPE; sudo chown $USER:docker $PIPE )

declare app service args

while true; do

  read app service args < $PIPE
  status=$(docker inspect -f '{{.State.Status}}' ${app}_${service} 2>/dev/null)
  if [ "$status" == "running" ]; then
    docker exec ${app}_${service} docker-service-callback.sh ${args} &
  fi
done

exit
